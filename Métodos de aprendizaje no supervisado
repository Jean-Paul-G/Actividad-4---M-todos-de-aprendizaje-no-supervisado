import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Crear el dataset con las características mencionadas
data = {
    'Nodo_Origen': ['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', 'E'],
    'Nodo_Destino': ['B', 'C', 'C', 'D', 'D', 'F', 'E', 'F', 'F'],
    'Distancia_km': [4, 5, 7, 2, 5, 3, 1, 2, 2],
    'Tiempo_Viaje_min': [10, 12, 15, 5, 10, 8, 3, 6, 5],
    'Demanda_Pasajeros': [120, 90, 150, 80, 100, 110, 60, 70, 50],
    'Nivel_Congestion': ['Medio', 'Medio', 'Alto', 'Bajo', 'Medio', 'Alto', 'Bajo', 'Medio', 'Bajo'],
    'Frecuencia_Servicio': [5, 4, 6, 8, 5, 3, 7, 4, 6]
}

# Crear un DataFrame
df = pd.DataFrame(data)

# Convertir la columna 'Nivel_Congestion' en valores numéricos
from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
df['Nivel_Congestion'] = label_encoder.fit_transform(df['Nivel_Congestion'])

# Normalización de los datos para el clustering
scaler = StandardScaler()
features = ['Distancia_km', 'Tiempo_Viaje_min', 'Demanda_Pasajeros', 'Nivel_Congestion', 'Frecuencia_Servicio']
scaled_features = scaler.fit_transform(df[features])

# Aplicación del modelo de clustering K-means
kmeans = KMeans(n_clusters=3, random_state=42)
clusters = kmeans.fit_predict(scaled_features)

# Añadir los resultados de los clusters al dataset original
df['Cluster'] = clusters

# Visualización de los resultados
plt.scatter(df['Distancia_km'], df['Demanda_Pasajeros'], c=df['Cluster'], cmap='viridis')
plt.xlabel('Distancia (km)')
plt.ylabel('Demanda de Pasajeros')
plt.title('Clustering de Rutas según Distancia y Demanda de Pasajeros')
plt.colorbar(label='Cluster')
plt.show()

# Mostrar el dataset final con los clusters asignados
print(df)
